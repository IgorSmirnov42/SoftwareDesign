### Run ###

`./gradlew run --console=plain`

### Architecture ###

https://drive.google.com/file/d/1hQdNZnXyPr_hBnZ--pvhTXHbayCeAU9l/view?usp=sharing

### Описание архитектуры ###

За подстановку переменных окружения отвечает блок `Substitute`, реализованный в виде конечного автомата. 

Переменные окружения хранятся в `Environment`. При создании в `Environment` записываются все внешние переменные окружения.

После подстановки переменных окружения происходит парсинг. Для него использую `ANTLR`. В результате парсинга получаю список `Executable` объектов -- команды в пайплайне.

Каждая команда реализует интерфейс `Executable`. Конструктор принимает аргументы, а метод `execute` -- набор стримов.

Объекты `Executable` создаются с помощью фабрики.

Команда `pwd` принимает `Environment`, так как должна получать текущую директорию (а логика её получения находится там), а команда `exit` принимает `Shell`, так как должна завершать его.

Далее в работу вступает `Executor`. Он поочерёдно, в одном потоке, запускает все команды из пайпа. Если код возврата какой-либо команды отличен от 0, исполнение прекращается и возвращается этот код.

### Grep ###

Были рассмотрены следующие библиотеки:

* JCommander

* cli-parser

* Argparse4j

* Apache Commons CLI

Первые две библиотеки используют аннотации. `JCommander` довольно популярная и очень удобная. Там отличная документация и гибкие параметры. Единственная проблема (как и у всех нижеперечисенных библиотек) -- нужно будет менять usage, потому что у грепа целых два параметра безымянные (шаблон и файлы). Не поддерживает передачу аргументов в виде `-iw`, но это, наверное, не очень важно. 

`cli-parser` умеет чуть меньше, чем `JCommander`, документация хуже.

Остальные две библиотеки используют паттерн Builder. Из этого следует, что для пользования ими нужно написать в разы больше кода. А для такой мелкой задачи писать 100500 неинтеллектуальных строк совсем не хочется. 

`Argparse4j` довольно популярная библиотека для разбора аргументов. Умеет в умные подсказки (например, подскажет, что в аргументе `--tpye` опечатка и, наверное, имелось в виду `--type`. Но в нашем случае это неактуально, так как все аргументы у нас однобуквенные.

`Apache Commons CLI`  -- самая популярная библиотека. Документация не очень. В официальном мане советуют пользоваться Deprecated методами.

Таким образом, в итоге остановился на `JCommander`.
